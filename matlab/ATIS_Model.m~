% Model ATIS

%% ========================= PARAMAMETERS MOSFET  ================= %%

%{
close all;clc;clear;

curr_pwd = pwd;

tic;

%PATH_input = '/home/netware/users/jpgironruiz/Desktop/Documents/Cadence_analysis/Inputs/spiral8X8_250/';
%PATH_input = getenv('PATH_folder_input'); %'/home/netware/users/jpgironruiz/Desktop/Documents/Cadence_analysis/Inputs/TrianguleWave7X8_250/';
%PATH_folder_images = getenv('PATH_folder_images'); % '/home/netware/users/jpgironruiz/Desktop/Documents/Cadence_analysis/Inputs/TrianguleWave7X8_250/';
%name_signal = getenv('name_Signalsinput') %'TrianguleWave7X8_250';
%name_signal = 'spiral8X8_250';
%N = str2num(getenv('N')); %7;
%M = str2num(getenv('M')); %8;

PATH_input = '/home/netware/users/jpgironruiz/Desktop/Documents/Cadence_analysis/Inputs/illuminationAtis8X8_150_4/';
name_signal = 'illuminationAtis8X8_150_4';
N = 8;
M = 8;

%% Transistor's parameters
nn = 1.334;
np = 1.369;
Vtn = 359.2e-3;
Vtp = 387e-3;
Kn = 227.1e-6;
Kp = 48.1e-6;
fi = 25.8e-3;
Ratio = 0.5e-6/2e-6;
Isn = 2*nn*fi^2*Kn*Ratio;

% Known vaiables
Vref = 1.5;
V_p = 1.35;          % V_tetha+
V_n = 1.65;         % V_tetha-
Vos = 5.42e-3;      % Voffset comparador
Iph_max = 1e-9;
Iph_min = 20e-12;
A = 20;             % Gain closed loop differentiator

VdiffON = V_p - Vref + Vos;  
VdiffOFF= V_n - Vref + Vos;

%% ====================== Model DVS =========================== %%

name_input = strcat(PATH_input,name_signal,'_0.csv');
input_signal = importdata(name_input);
t = input_signal(:,1);
len_t = length(t);
quant_pixel = N*M;
Vdiff=zeros(len_t,quant_pixel);
Vdiff_ind = zeros(len_t,1);
% structure ON 
ON_events = {[]};
% structure OFF event
OFF_events = {[]};
Events = {[]};
Event_pix = {[]};

ind_ON = 1;
ind_OFF = 1;
ind_events = 1;

cd(PATH_input)

for i=0:quant_pixel-1;

    % paso 1. Encontrar Vdiff para cada uno de los pixeles
    name_input = strcat(name_signal,'_',num2str(i),'.csv');
    input_signal = importdata(name_input);
    Iph = input_signal(:,2);
    log_Iph = log(Iph/Isn);
    Vdiff(:,i+1) = -nn*fi*A*log_Iph;
    Vdiff_ind = Vdiff(:,i+1);
    Vdiff_max = max(Vdiff_ind);    %used to normalized
    Vdiff_ind = Vdiff_ind - Vdiff_max; %used to normalized
    
    % Paso 2. Encontrar los eventos ON y OFF.
    ON_events = {[]};
    OFF_events = {[]};
    Event_pix = {[]};
    ind_events = 1;
    for j=1:len_t
       value = Vdiff_ind(j);
       if (value <= VdiffON)
           Vdiff_ind(j:len_t) = Vdiff_ind(j:len_t) + abs(value); %reset to Vref
           vec_time_pix = [t(j) i];
           ON_events{ind_ON} = vec_time_pix;
           Event_pix.value(ind_events) = t(j);
           ind_events = ind_events + 1;
           ind_ON = ind_ON + 1;
           
       else
           if ( value >= VdiffOFF)

                Vdiff_ind(j:len_t) = Vdiff_ind(j:len_t) - abs(value); %reset to Vref
                vec_time_pix = [t(j) i];
                OFF_events{ind_OFF} = vec_time_pix;
                Event_pix.value(ind_events) = t(j);
                ind_events = ind_events + 1;
                ind_OFF = ind_OFF + 1;
           else
               continue
           end
       end

    end
    Vdiff(:,i+1) = Vdiff_ind;
    Events{i+1} = Event_pix;
end

% figure(1)
% subplot(2,1,1)
% plot(t,Vdiff(:,1))
% xlim([0 0.00013])

%% ========================================================= %%

%% =============== Exposure Measurement ==================== %%

Vint = zeros(len_t,quant_pixel);
C = 30e-15;
Vhigh = 1.7;
Vlow = 200e-3;
Matrix_Color = {[]};
Color_pix = {[]};
i = 0;
ack_Rst = 0;
ack_Vhigh = 0;
vec_Times_events_pixels = zeros(1,quant_pixel);

for i=0:quant_pixel-1;
    cd(PATH_input)
    name_input = strcat(name_signal,'_',num2str(i),'.csv');
    input_signal = importdata(name_input);
    Iph = input_signal(:,2);
    Vo = 0;
    Event_pix = Events{i+1};
    time_events = Event_pix.value;
    ind_events = 1;
    Vint(1,i+1) = Vo;
    for j=2:len_t-1
        
        if ~(isempty(find(time_events == t(j),1)))
           Vo = 1.8;
           Vint(j,i+1) = Vo;
           ack_Rst = 1;
        else
            
            Vint(j,i+1) = -1/C*Iph(j)*(t(j)-t(j-1)) + Vo;
            
            if Vint(j,i+1) < 0 
                
               Vint(j,i+1) = 0; 
            end
            
            Vo = Vint(j,i+1);
            
            
            
            if Vint(j,i+1) <= Vhigh && ack_Rst
                ack_Rst = 0;
                t_high = t(j);
                ack_Vhigh = 1;
                
            elseif Vint(j,i+1) <= Vlow && ack_Vhigh
                t_low = t(j);
                T_int = t_low - t_high;
                cd(curr_pwd)
                Color = CodingGrayScale(Vhigh,Vlow,T_int);
                Color_pix.vec_color(ind_events) = Color;
                Color_pix.vec_time(ind_events) = t(j);
                total_events = ind_events;
                ind_events = ind_events + 1;
                ack_Vhigh = 0;
            end
            
        end
        
        %hold on
        %grid on
           
    end
    vec_Times_events_pixels(i+1) = total_events;
    Matrix_Color{i+1} = Color_pix;
  
end

%}

%% ====================== Painting the images ======================== %%

close all;clear input_signal Iph

len_Matrix_Color = length(Matrix_Color);
max_Events = max(vec_Times_events_pixels); % se calcula cuanto es el mayor numero de eventos asi mismo sera el de imagenes
Matrix_paint = zeros(M,N);
Matrix_grayscale = [];
struct_lims = {[]};
vec_time_frame = zeros(N*M,1);  % se usa para decir en la grafica el rango de tiempo
vec_color_frame = zeros(N*M,1);

Matrix_paint(:,:) = NaN;
vec_time_frame(:) = NaN;
vec_color_frame(:) = NaN;

%% setting the numbers from 0 to N-1 for the columns and 0 to M-1 for Rows
% it works only with square matrixes.
for x=0:N-1
    
    struct_lims{x+1} = num2str(x);
    
end

%% Get the ranges to plot
for i=1:max_Events
    ind_MGS = 1;
    for j=1:len_Matrix_Color
       
        vec_time = Matrix_Color{j}.vec_time;
        vec_color = Matrix_Color{j}.vec_color;
        indx = fix((j-1)/M);
        indy = rem(j-1,N);
        indx = indx + 1;
        indy = indy + 1;
        if length(vec_time) >= i
            Matrix_paint(indx,indy) = vec_color(i);
            Matrix_grayscale(ind_MGS,1) = vec_color(i)/255;
            ind_MGS = ind_MGS + 1;
        end
            
    end
    
    %% Creating the image
    h = figure('Visible','on');
    imagesc(uint8(Matrix_paint),[0 255])
    cmap = unique(Matrix_grayscale); % Elimina los valores repetidos y organiza de menos a más
    colorbar
    colorbar('YTick',[1:length(cmap)])
    colorbar('YTickLabel',num2str(uint8(255*cmap)))
    set(gca,'XTick',[1:N])
    set(gca,'YTick',[1:M])
    set(gca,'XTickLabel',struct_lims)
    set(gca,'YTickLabel',struct_lims)
    
    colormap([cmap cmap cmap])
    %colorbar('YTick',[1 2])
    grid off;
    xlabel('Columns')
    ylabel('Rows')
    caxis([min(min(Matrix_paint)) max(max(Matrix_paint))]);
    
    %lim_inf = (samples)*fr+1;
    %lim_sup = lim_inf + (samples-1);
    %title(strcat('Time = [ ',num2str(vec_time(lim_inf)*1e3),' - ', ...
    %    num2str(vec_time(lim_sup)*1e3),'] ms',' Frame = ',num2str(fr)))
    
    
    % Setting the lines vertical and horizontal at the image
    
    vc_lineX = linspace(0,N+1,200);
    vc_lineY = ones(1,length(vc_lineX))/2;
    
    for x=1:N
        
        for y=1:M
            
            hold on;
            plot(vc_lineX,vc_lineY+y);
            
        end
        hold on
        line([x+0.5 x+0.5],[0 M+1])
    end
    
    
    %saveas(gca,strcat('Frame_',num2str(fr)),'png')
    
end

%text(5,5,['\color{white}' 't=' num2str(4)],'HorizontalAlignment','center')
tic
toc
cd(curr_pwd)
